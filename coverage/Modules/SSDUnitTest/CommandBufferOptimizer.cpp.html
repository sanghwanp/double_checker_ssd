<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
	<head>
        <meta charset="utf-8"/>
	    <title>CommandBufferOptimizer.cpp</title>
	    <link href="../../third-party/google-code-prettify/prettify-CppCoverage.css" type="text/css" rel="stylesheet" />
	    <script type="text/javascript" src="../../third-party/google-code-prettify/prettify.js"></script>
	</head>
    <body onload="prettyPrint()">
        <h4></h4>
        <pre class="prettyprint lang-cpp linenums">
#include "CommandBufferOptimizer.h"

#include &lt;algorithm&gt;
#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;map&gt;
#include &lt;string&gt;
#include &lt;unordered_map&gt;
#include &lt;vector&gt;

#include "CommandBufferEntry.h"
#include "CommandBufferConfig.h"

typedef unsigned int uint;
typedef unsigned long long ull;

std::vector&lt;CommandBufferEntry&gt; CommandBufferOptimizer::Optimize(
<span style = "background-color:#dfd">    const std::vector&lt;CommandBufferEntry&gt;&amp; in_cmds) {
  std::vector&lt;CommandBufferEntry&gt; cmds = in_cmds;</span>

<span style = "background-color:#dfd">  unsigned long long orderMask = INIT_ORDER_MASK;
  for (int i = 0; i &lt; cmds.size(); i++) {
    if (cmds[i].data == 0) {
      cmds[i].cmdType = eEraseCmd;  // Write 0ì ì ë¶ Eraseë¡ ì·¨ê¸</span>
    }
<span style = "background-color:#dfd">    if (cmds[i].cmdType == eWriteCmd) {
      cmds[i].data |= orderMask;
      orderMask = (orderMask &lt;&lt; 1) | orderMask;</span>
    }
  }
<span style = "background-color:#dfd">  std::unordered_map&lt;uint, ull&gt; lba_data_udic;</span>

  // 1. ìµì¢ ë©ëª¨ë¦¬ ìí ë§ë¤ê¸°
<span style = "background-color:#dfd">  for (int i = 0; i &lt; cmds.size(); i++) {
    for (int lba = cmds[i].startLba; lba &lt;= cmds[i].endLba; lba++) {
      lba_data_udic[lba] = cmds[i].data;</span>
    }
  }

  // 2. ullë³ uint ì¶ì¶ (ìµì¢ ìí ê¸°ì¤)
<span style = "background-color:#dfd">  std::unordered_map&lt;ull, std::vector&lt;bool&gt;&gt; data_lbaChk_udic;
  for (auto it = lba_data_udic.begin(); it != lba_data_udic.end(); it++) {
    uint lba = it-&gt;first;
    ull data = it-&gt;second;</span>

<span style = "background-color:#dfd">    if (data_lbaChk_udic[data].empty()) {
      data_lbaChk_udic[data].resize(CommandBufferConfig::MAX_LBA_CNT, false);</span>
    }

<span style = "background-color:#dfd">    data_lbaChk_udic[data][lba] = true;</span>
  }

  // 3. CommandBufferì ì¡´ì¬íë dataë¤ì ì¤ë³µ ì ê±°íì¬ listë¡ ë§ë¦.
<span style = "background-color:#dfd">  std::vector&lt;ull&gt; data_list;
  for (int i = 0; i &lt; cmds.size(); i++) {
    data_list.push_back(cmds[i].data);</span>
  }
<span style = "background-color:#dfd">  std::sort(data_list.begin(), data_list.end());
  data_list.erase(std::unique(data_list.begin(), data_list.end()),</span>
                  data_list.end());

  // 4. ì´ë¤ ullë¶í° ì¨ì¼ ë®ì´ì°ê¸°ë¡ ëªë ¹ê°ìë¥¼ ìµìí í  ì ìëì§
  //    next_permutation()ì¼ë¡ ëª¨ë  ê²½ì°ì ìë¥¼ ë¤ í´ë´.
<span style = "background-color:#dfd">  std::vector&lt;int&gt; covered(CommandBufferConfig::MAX_LBA_CNT, -1);
  std::vector&lt;CommandBufferEntry&gt; result, ansResult;
  int mnResultCnt = INF;</span>
  do {
<span style = "background-color:#dfd">    result.clear();
    covered.clear();
    covered.resize(CommandBufferConfig::MAX_LBA_CNT, -1);</span>

<span style = "background-color:#dfd">    for (int i = 0; i &lt; data_list.size(); ++i) {
      ull data = data_list[i];
      std::vector&lt;bool&gt;&amp; lbaChk = data_lbaChk_udic[data];
      if (lbaChk.empty()) continue;</span>

<span style = "background-color:#dfd">      uint mnLba = INF, mxLba = 0;
      for (uint lba = 0; lba &lt; CommandBufferConfig::MAX_LBA_CNT; lba++) {
        if (lbaChk[lba]) {
          mnLba = std::min(mnLba, lba);
          mxLba = std::max(mxLba, lba);</span>
        }
      }

<span style = "background-color:#dfd">      uint startLba = CommandBufferConfig::NOT_AVAILABLE, endLba = mnLba;
      for (uint lba = mnLba; lba &lt;= mxLba; lba++) {
        if (lbaChk[lba]) {</span>
          if (startLba == CommandBufferConfig::NOT_AVAILABLE) startLba = lba;
<span style = "background-color:#dfd">          endLba = lba;
          covered[lba] = data;
        } else {</span>
          // ë¤ë¥¸ ê°(val)ì´ í´ë¹ lbaë¥¼ coveríì ì´ ìë¤ë©´,
<span style = "background-color:#dfd">          if (covered[lba] &gt;= 0) {
            endLba = lba;  // ê·¸ë¥ coverí´ë ë¨.
          } else {</span>
            // ìë¡ì´ êµ¬ê° ìì±
<span style = "background-color:#dfd">            result.push_back(CommandBufferEntry(startLba, endLba, data));
            startLba = CommandBufferConfig::NOT_AVAILABLE;  // startì§ì  ì´ê¸°í</span>
          }
        }
      }
<span style = "background-color:#dfd">      if (startLba != CommandBufferConfig::NOT_AVAILABLE) {
        result.push_back(CommandBufferEntry(startLba, endLba, data));</span>
      }
    }

    // 1ë²ì§¸ íì²ë¦¬: êµ¬ê° ê° ì¤ì´ê¸°
    int mnTotalIntvLength = INF;
<span style = "background-color:#dfd">    int totalIntvLength = 0;
    for (int i = 0; i &lt; result.size(); i++) {
      int sLba = result[i].startLba;
      for (int j = sLba; j &lt;= result[i].endLba; j++) {
        if (lba_data_udic.count(j) == 0 ||</span>
            lba_data_udic.at(j) != result[i].data)
<span style = "background-color:#fdd">          sLba++;</span>
        else
          break;
      }
      int eLba = result[i].endLba;
<span style = "background-color:#dfd">      for (int j = eLba; j &gt;= sLba; j--) {
        if (lba_data_udic.count(j) == 0 ||</span>
            lba_data_udic.at(j) != result[i].data)
<span style = "background-color:#dfd">          eLba--;</span>
        else
          break;
      }
<span style = "background-color:#dfd">      result[i].startLba = sLba;
      result[i].endLba = eLba;
      totalIntvLength += result[i].Length();</span>
    }

    // 2ë²ì§¸ íì²ë¦¬: ì²ìì ë¶ìë Mask bitë¥¼ dataìì ë¼ì´ì¤ë¤.
<span style = "background-color:#dfd">    for (int i = 0; i &lt; result.size(); i++) {
      result[i].data &amp;= REAL_DATA_MASK;
      if (result[i].data == 0) result[i].cmdType = eEraseCmd;</span>
    }

    // 3ë²ì§¸ íì²ë¦¬: ERASEê° 10ê° ëì´ê°ë©´ ëì´ì¤ë¤.
<span style = "background-color:#dfd">    std::vector&lt;CommandBufferEntry&gt; newResult;
    for (int i = 0; i &lt; result.size(); i++) {</span>
      // if (result[i].cmdType == eEraseCmd) { //-&gt; WRITEë ê·¸ë¥
      // ëì´ì£¼ì.
<span style = "background-color:#dfd">      while (result[i].Length() &gt; 0) {
        int ne = std::min(result[i].startLba + 10 - 1, result[i].endLba);
        CommandBufferEntry newInterval(result[i].cmdType, result[i].startLba,</span>
                                       ne, result[i].data);
<span style = "background-color:#dfd">        newResult.push_back(newInterval);
        result[i].startLba = ne + 1;</span>
      }
      //}
    }

<span style = "background-color:#dfd">    if (mnResultCnt &gt; newResult.size()) {
      mnResultCnt = newResult.size();
      ansResult = newResult;
      std::reverse(ansResult.begin(), ansResult.end());</span>
      // ans_writeOrder = writeOrder;
    }
<span style = "background-color:#dfd">  } while (std::next_permutation(data_list.begin(), data_list.end()));
  return ansResult;
}</span></pre>
        <hr />
        <table width="100%">
            <thead>
                <tr>
                    <th align="center">
                        <small>Generated by</small>
                        <a href="https://github.com/OpenCppCoverage/OpenCppCoverage/releases">
                            <strong>OpenCppCoverage (Version: 0.9.9.0)</strong>
                        </a>
                    </th>
                </tr>
            </thead>
        </table>
    </body>
</html>